# Redis 持久化机制

<br>
<br>

## 1. redis持久化之RDB（redis database）
1. 是什么？ <br>
   在指定的```时间间隔```内将内存中的```数据集快照```写入磁盘，也就是行话讲的snapshot快照，它恢复时是将快照文件直接读到内存里。
   
2. 备份是如何执行的？ <br>
   Redis 会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。 
   整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，
   那 RDB 方式要比 AOF方式更加的高效。**RDB 的缺点是最后一次持久化后的数据可能丢失** 。

3. fork
   + Fork 的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程
   
   + 在Linux 程序中，fork()会产生一个和父进程完全相同的子进程，但子进程在此后多会exec 系统调用，出于效率考虑，Linux 中引入了“写时复制技术”
   
   + 一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。
   
4. 劣势
   + Fork 的时候，内存中的数据被克隆了一份，大致 2 倍的膨胀性需要考虑
   
   + 虽然 Redis 在 fork 时使用了写时拷贝技术,但是如果数据庞大时还是比较消耗性能。
   
   + 在备份周期在一定间隔时间做一次备份，所以如果 redis 意外 down 掉的话，就会丢失最后一次快照后的所有修改。
   
5. 优势
   + 适合大规模的数据恢复
   
   + 对数据完整性和一致性要求不高更适合使用
   
   + 节省磁盘空间
   
   + 恢复速度快



<br>
<br>
<br>

## 2. redis持久化之AOF（Append Only File）
1. 是什么？ <br>
   以日志的形式来记录每个写操作（增量保存），将 Redis 执行过的所有写指令记录下来(读操作不记录)， 只许追加文件但不可以改写文件，
   redis 启动之初会读取该文件重构建数据，换言之，redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。
   
2. AOF默认不开启 <br>
   可以在 redis.conf 中配置文件名称，默认为appendonly.aof <br>
   AOF 文件的保存路径，同 RDB 的路径一致。
   
3. AOF和RDB同时开启，redis 听谁的？ <br>
   AOF和RDB同时开启, 系统默认取AOF的数据（数据不会存在丢失）
   
4. AOF 同步频率设置
   + appendfsync always <br>
     始终同步，每次 Redis 的写入都会立刻记入日志；性能较差但数据完整性比较好。
     
   + appendfsync everysec  <br>
     每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失。
     
   + appendfsync no.  <br>
     redis 不主动进行同步，把同步时机交给操作系统。

5. AOF持久化的流程
   1. 客户端的请求写命令会被 append 追加到 AOF 缓冲区内；
   
   2. AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync 同步到磁盘的AOF 文件中 ;
   
   3. AOF文件大小超过重写策略或手动重写时，会对 AOF 文件 rewrite 重写，压缩AOF文件容量；
   
6. 劣势
   + 比起RDB占用更多的磁盘空间
   
   + 恢复备份速度要慢
   
   + 每次读写都同步的话，有一定的性能压力
   
   + 存在个别bug，造成恢复不能。
   
7. 优势
   + 备份机制更稳健，丢失数据概率更低。
   
   + 可读的日志文本，通过操作AOF文件，可以处理误操作。
























