## 1. redis为什么快
+ ANSI C 编写，语言层面决定了性能高

+ 基于内存：redis是使用内存存储，没有磁盘IO上的开销。数据存在内存中，读写速度快。
+ 单线程实现（redis6.0以前）：redis使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销。
+ IO多路复用模型：redis采用IO多路复用技术。redis使用单线程来轮询描述符，将数据库的操作都转换成了事件，不存在网络I/O上浪费过多的时间。
+ 高效的数据结构：redis每种数据类型底层都做了优化，目的就是为了追求更快的速度。



<br>
<br>
<br>

## 2. redis（6.0以前）为什么采用单线程实现
+ 单线程实现可以避免过多的上下文切换开销。程序始终运行在进程中单个线程内，没有多线程切换的场景。

+ 避免同步机制的开销。如果redis选择多线程模型，需要考虑数据同步的问题，则必然会引入某些同步机制，会导致在操作数据过程中带来更多的开销，
  增加程序复杂度的同时还会降低性能。
+ 实现简单，方便维护。如果redis使用多线程模型，那么所有的底层数据结构的设计都必须考虑线程安全问题，那么redis的实现将会变得更加复杂。




<br>
<br>
<br>

## 3. redis怎么实现消息队列
1. 使用列表，让生产者将任务使用lpush命令放进列表，消费者不断用rpop从列表取出任务。

2. 发布订阅模式。类似于MQ的主题模式。只能消费订阅之后发布的消息，一个消息可以被多个订阅者消费。

3. 延时队列。使用sortedset，拿时间戳作为score，消息内容作为key，调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。




<br>
<br>
<br>

## 4. redis key的过期删除策略
1. 被动删除。在访问key时，如果发现key已经过期，那么会将key删除。

2. 主动删除。定时清理key，每次清理会依次遍历所有DB，从db随机取出20个key，如果过期就删除，如果其中有5个key过期，那么就继续对这个db进行清理，否则开始清理下一个db。

3. 内存不够时清理。redis有最大内存的限制，通过maxmemory参数可以设置最大内存，当使用的内存超过了设置的最大内存，就要进行内存释放，在进行内存释放的时候，会按照配置的淘汰策略清理内存。


<br>
<br>
<br>

## 5. redis的内存淘汰策略
![](.redis_相关问题_images/8571ed81.png)















































