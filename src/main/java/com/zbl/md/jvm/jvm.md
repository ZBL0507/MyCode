## item1: G1垃圾收集器
G1是一种服务器端的垃圾收集器， 应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能的满足垃圾收集器暂停时间的要求。另外，它还具有以下特性：
+ 像CMS收集器一样，能与应用程序线程并发执行

+ 整理空闲空间更快
+ 需要更多的时间来预测GC停顿时间
+ 不希望牺牲大量的吞吐性能
+ 不需要更大的java heap


<br>

G1收集器的设计目的是取代CMS收集器，它同CMS相比，在以下方面表现的更出色：
- G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片

- G1的stop-the-world(STW)更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。


<br>

主要改变是Eden, Survivor和Tenured等内存区域不再是连续的了，而是变成一个个大小一样的region，每个region从1M到32M不等，一个region有可能属于Eden,Survivor或者Tenured内存区域。

<br>

**G1特点**:
- G1能充分利用多CPU，多核环境硬件优势，尽量缩短STW

- G1整体上采用标记-整理算法，局部是使用复制算法，不会产生内存碎片
- 宏观上看G1之中不再区分年轻代和老年代，把内存划分成多个独立的子区域（region），可以近似理解为一个围棋的棋盘
- G1收集器里面将整个内存都混合在一起了，但其本身依然在小范围内要进行年轻代和老年代的区分，保留了新生代和老年代，但它们不再是物理隔离的，
  而是一部分region的集合且不需要region是连续的，也就是说依然会采用不同的GC方式来处理不同的区域
- G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代和老年代的区别，也不需要完全独立survivor（to space）堆做复制准备,
  G1只有逻辑上的分代概念，或者说每个分区都可能随G1的运行在不同代之间前后切换

<br>

**region区域化垃圾收集器** <br>

区域化内存划片region，整体编出了一系列不连续的内存区域，避免了全内存的GC操作
    
核心思想是将整个堆区域划分成大小相同的子区域（region），在JVM启动时会自动设置这些子区域的大小，
    
在堆的使用上，G1并不要求对象的存储一定是物理上连续的只要逻辑上连续即可，每个分区也不会固定的为某个代服务，可以按需在年轻代和老年代之间切换。

启动时可以通过参数 -XX:G1HeapRegionSize=n 可指定分区大小（1M到32M，且必须是2的幂），
    
默认将堆划分为2048个分区
    
大小范围在1MB-32MB，最多能设置2048个区域，也即能够支持的最大内存为：32MB*2048=65536MB=64G内存

G1算法将堆划分为若干个区域（region）， 它仍然属于分代收集器

这些region的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者survivor空间

这些region的一部分包含老年代，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作，这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有CMS内存碎片问题的存在了
    
在G1中，还有一种特殊的区域，叫Humongous(巨大的)区域，如果一个对象占用的空间超过了分区容量的50%以上，G1收集器就认为这是一个巨型对象，这些巨型对象默认直接会被分配在老年代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。
为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象，如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC

<br>

**G1收集器下的Young GC** <br>
针对Eden区进行收集，Eden区耗尽会被触发，主要是小区域收集+形成连续的内存块，避免内存碎片

- Eden区的数据移动到survivor区，假如出现survivor区空间不够，Eden区数据会部分晋升到old区

- survivor区的数据移动到新的survivor区，部分数据会晋升到old区
- 最后Eden区收拾干净了，GC结束，用户的应用程序继续执行

<br>
    
**回收步骤：** <br>
- 初始标记：只标记GC Roots能直接关联到的对象

- 并发标记：进行GC Roots Tracing的过程
- 最终标记：修正并发标记期间，因程序运行导致标记发生变化的那一部分对象
- 筛选回收：根据时间来进行价值最大化的回收

<br>

**相应JVM参数：** <br>
+ -XX:+UseG1GC

+ -XX:G1HeapRegionSize=n                                 指定region大小
+ -XX:MaxGCPauseMillis=n                                 最大停顿时间
+ -XX:InitiatingHeapOccupancyPercent=n                   堆占用多少的时候就触发GC，默认为45
+ -XX:ConcGCThreads=n                                    并发GC使用的线程数
+ -XX:G1ReservePercent=n                                 空闲空间的预留内存百分比，默认是10%































