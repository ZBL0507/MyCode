【在java语言中，什么对象可作为GCRoot的对象？】
    a.java虚拟机栈中的引用的对象。 
    b.方法区中的类静态属性引用的对象。 （一般指被static修饰的对象，加载类的时候就加载到内存中。）
    c.方法区中的常量引用的对象。 
    d.本地方法栈中的JNI（native方法）引用的对象


【redis普通分布式锁存在一定的缺陷】
    [高可用问题]
    客户端1在Redis的master节点上拿到了锁
    Master宕机了，存储锁的key还没有来得及同步到Slave上
    master故障，发生故障转移，slave节点升级为master节点
    客户端2从新的Master获取到了对应同一个资源的锁
    　　于是，客户端1和客户端2同时持有了同一个资源的锁。锁的安全性被打破了。针对这个问题。
        Redis作者antirez提出了RedLock算法来解决这个问题

    [业务线超时问题]
    节点1：如果设置锁的过期时间为30MS,但是业务线可能因为网络或者数据量峰值出现导致执行时间超过了30MS，
           那么这时redis已经把锁给释放了，但是业务线却仍然在执行
    节点2 这时去获取锁，发现锁可以获取成功，这就造成了 同时有两个节点在执行同一个业务逻辑，
          则无法保证业务的幂等性（数据加上版本号处理，但仍然会对累加结果造成重复性错误），
          会造成数据重复处理，或者日志主键ID重复，同一订单两次计算金额，客户两次扣款等问题

    [Redisson]
    Redisson在这个问题上加上了自动续时，如果锁已经被持有，那么另一个线程试图再次获取锁时，会把已存在的锁重置过期时间，
    就相当于延长了当前锁的时间从而避免过期造成幂等性问题(采用LUA脚本代码加锁，LUA脚本在redis中具有原子性操作。)
    watch dog自动延期机制
    客户端1加锁的锁key默认生存时间才30秒，如果业务执行时间超过了30秒，客户端1还是需要一直持有这把锁，怎么办呢？
    简单！只要客户端1一旦加锁成功，就会启动一个watch dog看门狗，他是一个后台线程，会每隔10秒检查一下，
    如果客户端1还持有锁key，那么就会不断的延长锁key的生存时间。

    [Redisson分布式锁的缺点]
    其实上面那种方案最大的问题，就是如果你对某个redis master实例，写入了myLock这种锁key的value，此时会异步复制给对应的master slave实例。
    但是这个过程中一旦发生redis master宕机，主备切换，redis slave变为了redis master。
    接着就会导致，客户端2来尝试加锁的时候，在新的redis master上完成了加锁，而客户端1也以为自己成功加了锁。
    此时就会导致多个客户端对一个分布式锁完成了加锁。
    这时系统在业务语义上一定会出现问题，导致各种脏数据的产生。
    所以这个就是redis cluster，或者是redis master-slave架构的主从异步复制导致的redis分布式锁的最大缺陷：
    在redis master实例宕机的时候，可能导致多个客户端同时完成加锁，
    如果要追求强一致性，那么只能考虑zookeeper分布式锁，当然它们各有自己的优缺点。


【JVM参数】
    是否打印GC收集细节
        -XX:+PrintGCDetails
        -XX:-PrintGCDetails

    是否使用串行垃圾回收器
        -XX:+UseSerialGC
        -XX:-UseSerialGC

    是否打印出JVM参数
        -XX:+PrintCommandLineFlags
        -XX:-PrintCommandLineFlags

    打印出JVM所有参数
        -XX:+PrintFlagsFinal
        -XX:-PrintFlagsFinal
        -XX:+PrintFlagsInitial
        -XX:-PrintFlagsInitial


    调整堆大小
        -Xms268435456 等价于 -XX:InitialHeapSize=268435456
        -Xmx268435456 等价于 -XX:MaxHeapSize=268435456

    配置新生代老年代占比
        -XX:NewRatio=2  新生代:老年代 1:2 (默认)
        -XX:NewRatio=4  新生代:老年代 1:4

    配置新生代中eden和from和to的比例
        -XX:SurvivorRatio=8   eden:from:to=8:1:1 (默认)
        -XX:SurvivorRatio=4   eden:from:to=4:1:1



【垃圾收集器种类】
    串行垃圾回收器：
        它为单线程环境设计，且只使用一个线程进行垃圾回收，会暂停所有的用户进程，所以不适合服务器环境

    并行垃圾回收器：
        多个垃圾回收线程并行工作，此时用户线程是暂停的，适用于科学计算/大数据处理后台处理等弱交互场景

    并发垃圾回收器：
        用户线程和垃圾收集线程同时运行（不一定是并行，可能是交替执行），不需要停顿用户线程，互联网公司多用它，适用于对响应时间有要求的场景

    G1垃圾回收器：
        G1垃圾回收器将堆内存分割成不同的区域然后并发的对其进行垃圾回收


    UseConcMarkSweepGC              -XX:+UseConcMarkSweepGC                -XX:-UseConcMarkSweepGC
    参数配置：     -XX:+UseConcMarkSweepGC -XX:+PrintCommandLineFlags
    参数打印出：   -XX:InitialHeapSize=16777216 -XX:MaxHeapSize=268435456 -XX:MaxNewSize=89481216 -XX:MaxTenuringThreshold=6 -XX:OldPLABSize=16 -XX:+PrintCommandLineFlags -XX:+UseConcMarkSweepGC -XX:-UseLargePagesIndividualAllocation -XX:+UseParNewGC

    UseG1GC                         -XX:+UseG1GC                           -XX:-UseG1GC
    参数配置：     -XX:+UseG1GC -XX:+PrintCommandLineFlags
    参数打印出     -XX:InitialHeapSize=16777216 -XX:MaxHeapSize=268435456 -XX:+PrintCommandLineFlags -XX:+UseG1GC -XX:-UseLargePagesIndividualAllocation

    UseParNewGC                     -XX:+UseParNewGC                       -XX:-UseParNewGC
    参数配置：     -XX:+UseParNewGC -XX:+PrintCommandLineFlags
    参数打印出：   -XX:InitialHeapSize=16777216 -XX:MaxHeapSize=268435456 -XX:+PrintCommandLineFlags -XX:-UseLargePagesIndividualAllocation -XX:+UseParNewGC

    UseParallelGC                   -XX:+UseParallelGC                     -XX:-UseParallelGC
    参数配置：     -XX:+UseParallelGC -XX:+PrintCommandLineFlags
    参数打印出：   -XX:InitialHeapSize=16777216 -XX:MaxHeapSize=268435456 -XX:+PrintCommandLineFlags -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC

    UseParallelOldGC                -XX:+UseParallelOldGC                  -XX:-UseParallelOldGC
    参数配置：     -XX:+UseParallelOldGC -XX:+PrintCommandLineFlags
    参数打印出：   -XX:InitialHeapSize=16777216 -XX:MaxHeapSize=268435456 -XX:+PrintCommandLineFlags -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelOldGC

    UseSerialGC                     -XX:+UseSerialGC                       -XX:-UseSerialGC
    参数配置：     -XX:+UseSerialGC -XX:+PrintCommandLineFlags
    参数打印出：   -XX:InitialHeapSize=16777216 -XX:MaxHeapSize=268435456 -XX:+PrintCommandLineFlags -XX:-UseLargePagesIndividualAllocation -XX:+UseSerialGC
