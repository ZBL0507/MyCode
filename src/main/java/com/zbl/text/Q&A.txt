【在java语言中，什么对象可作为GCRoot的对象？】
    a.java虚拟机栈中的引用的对象。 
    b.方法区中的类静态属性引用的对象。 （一般指被static修饰的对象，加载类的时候就加载到内存中。）
    c.方法区中的常量引用的对象。 
    d.本地方法栈中的JNI（native方法）引用的对象
    e.所有被同步锁持有的对象


【redis普通分布式锁存在一定的缺陷】
    [高可用问题]
    客户端1在Redis的master节点上拿到了锁
    Master宕机了，存储锁的key还没有来得及同步到Slave上
    master故障，发生故障转移，slave节点升级为master节点
    客户端2从新的Master获取到了对应同一个资源的锁
    　　于是，客户端1和客户端2同时持有了同一个资源的锁。锁的安全性被打破了。针对这个问题。
        Redis作者antirez提出了RedLock算法来解决这个问题

    [业务线超时问题]
    节点1：如果设置锁的过期时间为30MS,但是业务线可能因为网络或者数据量峰值出现导致执行时间超过了30MS，
           那么这时redis已经把锁给释放了，但是业务线却仍然在执行
    节点2 这时去获取锁，发现锁可以获取成功，这就造成了 同时有两个节点在执行同一个业务逻辑，
          则无法保证业务的幂等性（数据加上版本号处理，但仍然会对累加结果造成重复性错误），
          会造成数据重复处理，或者日志主键ID重复，同一订单两次计算金额，客户两次扣款等问题

    [Redisson]
    Redisson在这个问题上加上了自动续时，如果锁已经被持有，那么另一个线程试图再次获取锁时，会把已存在的锁重置过期时间，
    就相当于延长了当前锁的时间从而避免过期造成幂等性问题(采用LUA脚本代码加锁，LUA脚本在redis中具有原子性操作。)
    watch dog自动延期机制
    客户端1加锁的锁key默认生存时间才30秒，如果业务执行时间超过了30秒，客户端1还是需要一直持有这把锁，怎么办呢？
    简单！只要客户端1一旦加锁成功，就会启动一个watch dog看门狗，他是一个后台线程，会每隔10秒检查一下，
    如果客户端1还持有锁key，那么就会不断的延长锁key的生存时间。

    [Redisson分布式锁的缺点]
    其实上面那种方案最大的问题，就是如果你对某个redis master实例，写入了myLock这种锁key的value，此时会异步复制给对应的master slave实例。
    但是这个过程中一旦发生redis master宕机，主备切换，redis slave变为了redis master。
    接着就会导致，客户端2来尝试加锁的时候，在新的redis master上完成了加锁，而客户端1也以为自己成功加了锁。
    此时就会导致多个客户端对一个分布式锁完成了加锁。
    这时系统在业务语义上一定会出现问题，导致各种脏数据的产生。
    所以这个就是redis cluster，或者是redis master-slave架构的主从异步复制导致的redis分布式锁的最大缺陷：
    在redis master实例宕机的时候，可能导致多个客户端同时完成加锁，
    如果要追求强一致性，那么只能考虑zookeeper分布式锁，当然它们各有自己的优缺点。


【JVM部分参数说明】
    DefNew       --------->   Default New Generation
    Tenured      --------->   Old
    ParNew       --------->   Parallel New Generation
    PSYoungGen   --------->   Parallel Scavenge
    ParOldGen    --------->   Parallel Old Generation



【JVM参数】
    是否打印GC收集细节
        -XX:+PrintGCDetails
        -XX:-PrintGCDetails

    是否使用串行垃圾回收器
        -XX:+UseSerialGC
        -XX:-UseSerialGC

    是否打印出JVM参数
        -XX:+PrintCommandLineFlags
        -XX:-PrintCommandLineFlags

    打印出JVM所有参数
        -XX:+PrintFlagsFinal
        -XX:-PrintFlagsFinal
        -XX:+PrintFlagsInitial
        -XX:-PrintFlagsInitial


    调整堆大小
        -Xms268435456 等价于 -XX:InitialHeapSize=268435456
        -Xmx268435456 等价于 -XX:MaxHeapSize=268435456

    配置新生代老年代占比
        -XX:NewRatio=2  新生代:老年代 1:2 (默认)
        -XX:NewRatio=4  新生代:老年代 1:4

    配置新生代中eden和from和to的比例
        -XX:SurvivorRatio=8   eden:from:to=8:1:1 (默认)
        -XX:SurvivorRatio=4   eden:from:to=4:1:1



【垃圾收集器种类】
    串行垃圾回收器：
        它为单线程环境设计，且只使用一个线程进行垃圾回收，会暂停所有的用户进程，所以不适合服务器环境

    并行垃圾回收器：
        多个垃圾回收线程并行工作，此时用户线程是暂停的，适用于科学计算/大数据处理后台处理等弱交互场景

    并发垃圾回收器：
        用户线程和垃圾收集线程同时运行（不一定是并行，可能是交替执行），不需要停顿用户线程，互联网公司多用它，适用于对响应时间有要求的场景

    G1垃圾回收器：
        G1垃圾回收器将堆内存分割成不同的区域然后并发的对其进行垃圾回收


    UseConcMarkSweepGC              -XX:+UseConcMarkSweepGC                -XX:-UseConcMarkSweepGC
    参数配置：     -XX:+UseConcMarkSweepGC -XX:+PrintCommandLineFlags
    参数打印出：   -XX:InitialHeapSize=16777216 -XX:MaxHeapSize=268435456 -XX:MaxNewSize=89481216 -XX:MaxTenuringThreshold=6 -XX:OldPLABSize=16 -XX:+PrintCommandLineFlags -XX:+UseConcMarkSweepGC -XX:-UseLargePagesIndividualAllocation -XX:+UseParNewGC

    UseG1GC                         -XX:+UseG1GC                           -XX:-UseG1GC
    参数配置：     -XX:+UseG1GC -XX:+PrintCommandLineFlags
    参数打印出     -XX:InitialHeapSize=16777216 -XX:MaxHeapSize=268435456 -XX:+PrintCommandLineFlags -XX:+UseG1GC -XX:-UseLargePagesIndividualAllocation

    UseParNewGC                     -XX:+UseParNewGC                       -XX:-UseParNewGC
    参数配置：     -XX:+UseParNewGC -XX:+PrintCommandLineFlags
    参数打印出：   -XX:InitialHeapSize=16777216 -XX:MaxHeapSize=268435456 -XX:+PrintCommandLineFlags -XX:-UseLargePagesIndividualAllocation -XX:+UseParNewGC

    UseParallelGC                   -XX:+UseParallelGC                     -XX:-UseParallelGC
    参数配置：     -XX:+UseParallelGC -XX:+PrintCommandLineFlags
    参数打印出：   -XX:InitialHeapSize=16777216 -XX:MaxHeapSize=268435456 -XX:+PrintCommandLineFlags -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC

    UseParallelOldGC                -XX:+UseParallelOldGC                  -XX:-UseParallelOldGC
    参数配置：     -XX:+UseParallelOldGC -XX:+PrintCommandLineFlags
    参数打印出：   -XX:InitialHeapSize=16777216 -XX:MaxHeapSize=268435456 -XX:+PrintCommandLineFlags -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelOldGC

    UseSerialGC                     -XX:+UseSerialGC                       -XX:-UseSerialGC
    参数配置：     -XX:+UseSerialGC -XX:+PrintCommandLineFlags
    参数打印出：   -XX:InitialHeapSize=16777216 -XX:MaxHeapSize=268435456 -XX:+PrintCommandLineFlags -XX:-UseLargePagesIndividualAllocation -XX:+UseSerialGC



【G1垃圾收集器】
    G1是一种服务器端的垃圾收集器， 应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能的满足垃圾收集器暂停时间的要求
    另外，它还具有以下特性：
    - 像CMS收集器一样，能与应用程序线程并发执行
    - 整理空闲空间更快
    - 需要更多的时间来预测GC停顿时间
    - 不希望牺牲大量的吞吐性能
    - 不需要更大的java heap

    G1收集器的设计目的是取代CMS收集器，它同CMS相比，在以下方面表现的更出色：
    - G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片
    - G1的stop-the-world(STW)更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。

    主要改变是Eden, Survivor和Tenured等内存区域不再是连续的了，而是变成一个个大小一样的region，
    每个region从1M到32M不等，一个region有可能属于Eden,Survivor或者Tenured内存区域。

    G1特点
    - G1能充分利用多CPU，多核环境硬件优势，尽量缩短STW
    - G1整体上采用标记-整理算法，局部是使用复制算法，不会产生内存碎片
    - 宏观上看G1之中不再区分年轻代和老年代，把内存划分成多个独立的子区域（region），可以近似理解为一个围棋的棋盘
    - G1收集器里面将整个内存都混合在一起了，但其本身依然在小范围内要进行年轻代和老年代的区分，保留了新生代和老年代，
        但它们不再是物理隔离的，而是一部分region的集合且不需要region是连续的，也就是说依然会采用不同的GC方式来处理不同的区域
    - G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代和老年代的区别，也不需要完全独立survivor（to space）堆做复制准备
        G1只有逻辑上的分代概念，或者说每个分区都可能随G1的运行在不同代之间前后切换

    region区域化垃圾收集器
    区域化内存划片region，整体编出了一系列不连续的内存区域，避免了全内存的GC操作
    核心思想是将整个堆区域划分成大小相同的子区域（region），在JVM启动时会自动设置这些子区域的大小，
    在堆的使用上，G1并不要求对象的存储一定是物理上连续的只要逻辑上连续即可，每个分区也不会固定的为某个代服务，
    可以按需在年轻代和老年代之间切换。启动时可以通过参数 -XX:G1HeapRegionSize=n 可指定分区大小（1M到32M，且必须是2的幂），
    默认将堆划分为2048个分区
    大小范围在1MB-32MB，最多能设置2048个区域，也即能够支持的最大内存为：32MB*2048=65536MB=64G内存

    G1算法将堆划分为若干个区域（region）， 它仍然属于分代收集器
    这些region的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者survivor空间
    这些region的一部分包含老年代，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作，这就意味着，在正常的处理
    过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有CMS内存碎片问题的存在了
    在G1中，还有一种特殊的区域，叫Humongous(巨大的)区域，如果一个对象占用的空间超过了分区容量的50%以上，G1收集器就认为
    这是一个巨型对象，这些巨型对象默认直接会被分配在老年代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。
    为了解决这个问题，G1划分了一个Humongous区，它用来专门存放巨型对象，如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区
    来存储。为了能找到连续的H区，有时候不得不启动Full GC

    G1收集器下的Young GC
    针对Eden区进行收集，Eden区耗尽会被触发，主要是小区域收集+形成连续的内存块，避免内存碎片
    - Eden区的数据移动到survivor区，假如出现survivor区空间不够，Eden区数据会部分晋升到old区
    - survivor区的数据移动到新的survivor区，部分数据会晋升到old区
    - 最后Eden区收拾干净了，GC结束，用户的应用程序继续执行

    回收步骤：
    - 初始标记：只标记GC Roots能直接关联到的对象
    - 并发标记：进行GC Roots Tracing的过程
    - 最终标记：修正并发标记期间，因程序运行导致标记发生变化的那一部分对象
    - 筛选回收：根据时间来进行价值最大化的回收

    相应JVM参数：
    -XX:+UseG1GC
    -XX:G1HeapRegionSize=n                                 指定region大小
    -XX:MaxGCPauseMillis=n                                 最大停顿时间
    -XX:InitiatingHeapOccupancyPercent=n                   堆占用多少的时候就触发GC，默认为45
    -XX:ConcGCThreads=n                                    并发GC使用的线程数
    -XX:G1ReservePercent=n                                 空闲空间的预留内存百分比，默认是10%

    G1相比CMS的优势
    - G1不会产生内存碎片
    - 可以精确控制停顿时间



【JVM垃圾回收】
    新生代：
        - 串行GC(Serial)/(Serial Copying)
            串行收集器：Serial收集器
            一句话：一个单线程的收集器，在进行垃圾回收的时候，必须暂停其他工作线程直到它收集结束
            串行收集器是最古老，最稳定以及效率高的收集器，只使用一个线程去回收但其在进行垃圾回收的过程中可能会产生比较长的停顿(Stop-The-World)状态
            虽然在收集垃圾的过程中需要暂停所有其他的工作线程，但是它简单高效，对于限定单个CPU环境来说，没有线程相互交互的开销可以获得最高的单线程垃圾收集效率，
            因此Serial收集器依然是java虚拟机运行在client模式下默认的新生代垃圾收集器
            对于的JVM参数是：-XX:+UseSerialGC
            开启后会使用：Serial(Young区用) + Serial Old(Old区用)的收集器组合
            表示：新生代、老年代都会使用串行垃圾收集器，新生代使用复制算法，老年代使用标记-整理算法
        - 并行GC(ParNew)
            一句话：使用多线程进行垃圾回收，在垃圾回收收集时，会Stop-the-World暂停其他所有的工作线程直到它收集结束。
            ParNew收集器其实就是Serial收集器新生代的并行多线程版本，最常见的应用场景时配合老年代CMS GC工作，其余的行为和Serial收集器完全一样，
            ParNew垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。它是很多java虚拟机运行在Server模式下新生代的默认垃圾收集器。
            常见对应jvm参数：-XX:+UseParNewGC 启动ParNew收集器，只影响新生代的收集，不影响老年代；
            开启后上述参数后，会使用ParNew(Young区用) + Serial Old的收集器组合，新生代使用复制算法，老年代采用标记--整理算法
            但是，ParNew+Tenured这样搭配，java8已经不再推荐了。
            备注：
                -XX:ParallelGCThreads 限制线程数量，默认开启和CPU数目相同的线程数
        - 并行回收GC(Parallel)/(Parallel Scavenge)
            并行收集器Parallel Scavenge收集器类似ParNew， 也是一个新生代垃圾收集器，使用复制算法，也是一个并行的多线程的垃圾收集器，称俗吞吐量优先收集器。
            一句话：串行收集器在新生代和老年代的并行化
            它关注的重点是：可控制的吞吐量（ThoughtPut=运行用户代码时间/(运行用户代码时间 + 垃圾收集时间)）。
                高吞吐量意味着高效利用CPU时间，它多用于在后台运算而不需要太多交互的任务。
            自适应调节策略也是Parallel Scavenge收集器于ParNew收集器的一个重要区别。（自适应调节策略：虚拟机会根据当前系统的运行情况收集性能监控信息，
                动态调整这些参数以提供最合适的停顿时间（-XX:MaxGCPauseMillis）或最大的吞吐量）
            常用JVM参数：-XX:+UseParallelGC 或 -XX:+UseParallelOldGC (可相互激活) 使用Parallel Scavenge收集器
                        新生代使用复制算法，老年代采用标记--整理算法

    老年代：
        - 串行回收GC(Serial Old)/(Serial MSC)
            Serial Old是Serial 垃圾收集器老年代版本，它同样是单线程的收集器，使用标记--整理算法，这个收集器也主要是运行在Clint默认的java虚拟机默认年老代垃圾收集器。
            在Server模式下，主要有两个途径(了解一下java8以后)
                1. jdk1.5之前版本中与新生代的Parallel Scavenge收集器搭建配置使用。(Parallel Scavenge+Serial Old)
                2. 作为老年代版本中使用CMS收集器的后备垃圾收集方案。
        - 并行GC(Parallel Old)/(Parallel MSC)
            Parallel Old收集器是Parallel Scavenge的老年代版本，使用多线程的标记--整理算法，Parallel Old收集器在jdk1.6才开始提供。
            在jdk1.6之前，新生代使用Parallel Scavenge收集器只能搭配老年代的Serial Old收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量。在jdk1.6之后(Parallel Scavenge+Serial Old)
            Parallel Old正是为了在年老代同样提供吞吐量优先的垃圾收集器，如果系统对吞吐量要求比较高，jkd1.8后可以优先考虑新生代Parallel Scavenge和年老代Parallel Old收集器的搭配策略。在jdk1.8k及后(Parallel Scavenge+Parallel Old )
            JVM常用参数：-XX:+UseParallelOldGC
                使用Parallel Old收集器，设置该参数后，新生代Parallel+老年代Parallel Old
        - 并发标记清除GC(CMS)
            CMS收集器(Concurrent Mark Sweep:并发标记清除)是一种以获取最短的回收停顿时间位目标的收集器。
            适合应用在互联网或者B/S系统的服务器上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短。
            CMS非常适合堆内存大、CPU核数多的服务器端应用，也是G1出现之前大型应用的首选收集器。并发标记清除组合 ParNew + CMS + Serial Old Concurrent Mark Sweep并发标记清除，并发收集低停顿，并发指的是与用户线程一起执行
            开启该收集器的JVM参数：-XX:+UseConcMarkSweepGC 开启该参数后会自动将-XX:+UseParNewGC 打开
                开启该参数后，使用ParNew(Young区用)+CMS(Old区用)+Serial Old的收集器组合，Serial Old将作为CMS出错的后备收集器
            并发标记清除GC(CMS)的执行过程分为4步
                1. 初始标记(CMS initial mark)
                2. 并发标记(CMS concurrent mark)和用户线程一起进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线程。主要标记过程，标记全部对象
                3. 重新标记(CMS remark)为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分的标记记录，仍然需要暂停所有的工作线程。
                    由于并发标记时，用户线程依然运行，因此在正式清理时，再做修正
                4. 并发清除(CMS concurrent sweep)和用户线程一起清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。主要标记结果，直接清理对象
            并发标记清除GC(CMS)优缺点
                优点：
                    并发收集低停顿
                缺点：
                    1. 并发执行，对CPU资源压力大
                    2. 采用的标记清除算法会导致大量碎片



【GC组合的选择】
    - 单CPU或小内存，单机程序
        -XX:+UseSerialGC
    - 多CPU，需要最大吞吐量，如后台计算型应用
        -XX:+UseParallelGC 或者
        -XX:+UseParallelOldGC
    - 多CPU，追求低停顿时间，需快速响应如互联网应用
        -XX:+UseConcMarkSweepGC
        -XX:+UseParNewGC



【Spring 循环依赖】
    Spring官网解释
    Circular dependencies
    If you use predominantly constructor injection, it is possible to create an unresolvable circular dependency scenario.

    For example: Class A requires an instance of class B through constructor injection,
    and class B requires an instance of class A through constructor injection.
    If you configure beans for classes A and B to be injected into each other,
    the Spring IoC container detects this circular reference at runtime,
    and throws a BeanCurrentlyInCreationException.

    One possible solution is to edit the source code of some classes to be configured by setters
    rather than constructors.
    Alternatively, avoid constructor injection and use setter injection only.
    In other words, although it is not recommended,
    you can configure circular dependencies with setter injection.

    Unlike the typical case (with no circular dependencies),
    a circular dependency between bean A and bean B forces one of the beans to be injected
    into the other prior to being fully initialized itself (a classic chicken-and-egg scenario).

    三级缓存解决循环依赖：
        一级缓存：
        /** Cache of singleton objects: bean name to bean instance. */
    	private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256);

    	三级缓存：
    	/** Cache of singleton factories: bean name to ObjectFactory. */
        private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16);

        二级缓存：
        /** Cache of early singleton objects: bean name to bean instance. */
        private final Map<String, Object> earlySingletonObjects = new ConcurrentHashMap<>(16);

    1. A创建过程中需要B， 于是A将自己放到三级缓存里面去， 去实例化B
    2. B实例化的时候发现需要A， 于是B先查一级缓存，没有，再查二级缓存，还是没有，再查三级缓存，找到了A
        然后把三级缓存里面的这个A放到二级缓存里面，并删除三级缓存里面的A
    3. B顺利初始化完毕，将自己放到一级缓存里面去（此时B里面的A依然是创建中状态）
        然后回来接着创建A，此时B已经创建结束，直接从一级缓存里面拿到B，然后完成创建，并将A自己放到一级缓存里面
