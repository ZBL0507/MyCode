【索引失效情况】
    - 不同的字符集进行比较前需要进行转换会造成索引失效

    - 隐式转换会导致索引失效如:
        select name, phone from customer where id = '111';

    - 避免使用双%号的查询条件。如：a like '%123%'，（如果无前置%,只有后置%，是可以用到列上的索引的）

    - 一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，
        则在 b,c 列上的索引将不会被用到

    - 在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，
        使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。

    - 通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,
        才可以把子查询转化为关联查询进行优化。
      子查询性能差的原因：
      子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，
        所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。
      由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。

    - 对应同一列进行 or 判断时，使用 in 代替 or
      in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。

    - 对列进行函数转换或计算时会导致无法使用索引
      不推荐：
      where date(create_time) = '20190101'
      推荐：
      where create_time >= '20190101' and create_time < '20190102'






【在明显不会有重复值时使用 UNION ALL 而不是 UNION】
    - UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作
    - UNION ALL 不会再对结果集进行去重操作


【拆分复杂的大 SQL 为多个小 SQL】
    - 大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL
    - MySQL 中，一个 SQL 只能使用一个 CPU 进行计算
    - SQL 拆分后可以通过并行执行来提高处理效率


【对于大表使用 pt-online-schema-change 修改表结构】
    - 避免大表修改产生的主从延迟
    - 避免在对表字段进行修改时进行锁表
    对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。
    pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，
    然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，
    在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。