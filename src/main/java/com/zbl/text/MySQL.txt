【MySQL两个时间字段】
    gmt_created    timestamp   default CURRENT_TIMESTAMP not null comment '创建时间',
    gmt_modify     timestamp   default CURRENT_TIMESTAMP not null on update CURRENT_TIMESTAMP comment '最后修改时间',


【工作中遇到的场景】
    - 当sql语句中的where过滤中使用的字段(带有索引)和order by 后面的字段不一致时，可能会导致索引变慢，出现文件排序



【索引失效情况】
    - 不同的字符集进行比较前需要进行转换会造成索引失效

    - 隐式转换会导致索引失效如:
        select name, phone from customer where id = '111';

    - 避免使用双%号的查询条件。如：a like '%123%'，（如果无前置%,只有后置%，是可以用到列上的索引的）

    - 一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，
        则在 b,c 列上的索引将不会被用到

    - 在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，
        使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。

    - 通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,
        才可以把子查询转化为关联查询进行优化。
      子查询性能差的原因：
      子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，
        所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。
      由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。

    - 对应同一列进行 or 判断时，使用 in 代替 or
      in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。

    - 对列进行函数转换或计算时会导致无法使用索引
      不推荐：
      where date(create_time) = '20190101'
      推荐：
      where create_time >= '20190101' and create_time < '20190102'






【在明显不会有重复值时使用 UNION ALL 而不是 UNION】
    - UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作
    - UNION ALL 不会再对结果集进行去重操作


【拆分复杂的大 SQL 为多个小 SQL】
    - 大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL
    - MySQL 中，一个 SQL 只能使用一个 CPU 进行计算
    - SQL 拆分后可以通过并行执行来提高处理效率


【对于大表使用 pt-online-schema-change 修改表结构】
    - 避免大表修改产生的主从延迟
    - 避免在对表字段进行修改时进行锁表
    对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。
    pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，
    然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，
    在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。


【事务的并发问题】
    1. 脏读：事务 A 读取了事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据
    2. 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果不一致。
    3. 系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，
        当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。
    小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表


【MySQL事务隔离级别】
    事务隔离级别	                   脏读	           不可重复读	               幻读
    读未提交（read-uncommitted）	    是	              是	                    是
    不可重复读（read-committed）	    否	              是	                    是
    可重复读（repeatable-read）	    否	              否	                    是
    串行化（serializable）	        否	              否	                    否


【事物的四大特性】
    - A 原子性/不可分割性(atomicity)
    - C 一致性(consistency)
    - I 隔离性(isolation)
    - D 持久性(durability)


【MySQL三种主要的日志】
    - 二进制日志( binlog )
    - 事务日志(包括redo log 和 undo log )

    [binlog]
    binlog 用于记录数据库执行的写入性操作(不包括查询)信息，以二进制的形式保存在磁盘中。
    binlog 是 mysql的逻辑日志，并且由 Server 层进行记录，使用任何存储引擎的 mysql 数据库都会记录 binlog 日志。
        逻辑日志：可以简单理解为记录的就是sql语句 。
        物理日志：mysql 数据最终是保存在数据页中的，物理日志记录的就是数据页变更 。
    binlog 是通过追加的方式进行写入的，可以通过max_binlog_size 参数设置每个 binlog文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。
    binlog使用场景
        在实际应用中， binlog 的主要使用场景有两个，分别是 主从复制 和 数据恢复 。
        主从复制 ：在 Master 端开启 binlog ，然后将 binlog发送到各个 Slave 端， Slave 端重放 binlog 从而达到主从数据一致。
        数据恢复 ：通过使用 mysqlbinlog 工具来恢复数据。

    [redo log]
    为什么需要redo log ?
    事务的四大特性里面有一个是 持久性 ，具体来说就是只要事务提交成功，那么对数据库做的修改就被永久保存下来了，不可能因为任何原因再回到原来的状态 。
    那么 mysql是如何保证一致性的呢？
    最简单的做法是在每次事务提交的时候，将该事务涉及修改的数据页全部刷新到磁盘中。但是这么做会有严重的性能问题，主要体现在两个方面：
    因为 Innodb 是以 页 为单位进行磁盘交互的，而一个事务很可能只修改一个数据页里面的几个字节，这个时候将完整的数据页刷到磁盘的话，太浪费资源了！
    一个事务可能涉及修改多个数据页，并且这些数据页在物理上并不连续，使用随机IO写入性能太差！
    因此 mysql 设计了 redo log ， 具体来说就是只记录事务对数据页做了哪些修改，这样就能完美地解决性能问题了(相对而言文件更小并且是顺序IO)。

    redo log 包括两部分：一个是内存中的日志缓冲( redo log buffer )，另一个是磁盘上的日志文件( redo logfile)。
    mysql 每执行一条 DML 语句，先将记录写入 redo log buffer，后续某个时间点再一次性将多个操作记录写到 redo log file。
    这种 先写日志，再写磁盘 的技术就是 MySQL 里经常说到的 WAL(Write-Ahead Logging) 技术。
    在计算机操作系统中，用户空间( user space )下的缓冲区数据一般情况下是无法直接写入磁盘的，中间必须经过操作系统内核空间( kernel space )缓冲区( OS Buffer )。

    [undo log]
    数据库事务四大特性中有一个是 原子性 ，具体来说就是 原子性是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况。
    实际上， 原子性 底层就是通过 undo log 实现的。undo log主要记录了数据的逻辑变化，
    比如一条 INSERT 语句，对应一条DELETE 的 undo log ，对于每个 UPDATE 语句，对应一条相反的 UPDATE 的 undo log ，这样在发生错误时，就能回滚到事务之前的数据状态。
    同时， undo log 也是 MVCC(多版本并发控制)实现的关键